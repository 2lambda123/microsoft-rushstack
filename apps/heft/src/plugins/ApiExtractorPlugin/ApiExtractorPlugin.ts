// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.

import * as path from 'path';
import { FileSystem } from '@rushstack/node-core-library';

import { IHeftPlugin } from '../../pluginFramework/IHeftPlugin';
import { HeftSession } from '../../pluginFramework/HeftSession';
import { HeftConfiguration } from '../../configuration/HeftConfiguration';
import { ApiExtractorRunner } from './ApiExtractorRunner';
import { IBuildStageContext, IBundleSubstage } from '../../stages/BuildStage';
import { CoreConfigFiles } from '../../utilities/CoreConfigFiles';
import { ScopedLogger } from '../../pluginFramework/logging/ScopedLogger';
import { RigConfig } from '@rushstack/rig-package';

const PLUGIN_NAME: string = 'ApiExtractorPlugin';
const CONFIG_FILE_LOCATION: string = './config/api-extractor.json';

export interface IApiExtractorPluginConfiguration {
  /**
   * If set to true, use the project's TypeScript compiler version for API Extractor's
   * analysis. API Extractor's included TypeScript compiler can generally correctly
   * analyze typings generated by older compilers, and referencing the project's compiler
   * can cause issues. If issues are encountered with API Extractor's included compiler,
   * set this option to true.
   *
   * This corresponds to API Extractor's `--typescript-compiler-folder` CLI option and
   * `IExtractorInvokeOptions.typescriptCompilerFolder` API option. This option defaults to false.
   */
  useProjectTypescriptVersion?: boolean;
}

interface IRunApiExtractorOptions {
  heftConfiguration: HeftConfiguration;
  buildFolder: string;
  debugMode: boolean;
  watchMode: boolean;
  production: boolean;
}

export class ApiExtractorPlugin implements IHeftPlugin {
  public readonly pluginName: string = PLUGIN_NAME;

  public apply(heftSession: HeftSession, heftConfiguration: HeftConfiguration): void {
    const { buildFolder } = heftConfiguration;
    heftSession.hooks.build.tap(PLUGIN_NAME, (build: IBuildStageContext) => {
      build.hooks.bundle.tap(PLUGIN_NAME, (bundle: IBundleSubstage) => {
        bundle.hooks.run.tapPromise(PLUGIN_NAME, async () => {
          const apiExtractorConfigExists: boolean = await this._doesAPiExtractorConfigExistAsync(
            heftConfiguration
          );

          if (apiExtractorConfigExists) {
            await this._runApiExtractorAsync(heftSession, {
              heftConfiguration,
              buildFolder,
              debugMode: heftSession.debugMode,
              watchMode: build.properties.watchMode,
              production: build.properties.production
            });
          }
        });
      });
    });
  }

  private async _runApiExtractorAsync(
    heftSession: HeftSession,
    options: IRunApiExtractorOptions
  ): Promise<void> {
    const { heftConfiguration, buildFolder, debugMode, watchMode, production } = options;

    const logger: ScopedLogger = heftSession.requestScopedLogger('API Extractor Plugin');
    const rigConfig: RigConfig = await CoreConfigFiles.getRigConfigAsync(heftConfiguration);
    const apiExtractorTaskConfiguration:
      | IApiExtractorPluginConfiguration
      | undefined = await CoreConfigFiles.apiExtractorTaskConfigurationLoader.tryLoadConfigurationFileForProjectAsync(
      logger.terminal,
      heftConfiguration.buildFolder,
      rigConfig
    );

    if (watchMode) {
      logger.terminal.writeWarningLine("API Extractor isn't currently supported in --watch mode.");
      return;
    }

    if (!heftConfiguration.compilerPackage) {
      logger.emitError(new Error('Unable to resolve a compiler package for tsconfig.json'));
      return;
    }

    if (!heftConfiguration.compilerPackage.apiExtractorPackagePath) {
      logger.emitError(
        new Error('Unable to resolve the "@microsoft/api-extractor" package for this project')
      );
      return;
    }

    const apiExtractorRunner: ApiExtractorRunner = new ApiExtractorRunner(
      heftConfiguration.terminalProvider,
      {
        configFileLocation: CONFIG_FILE_LOCATION,
        apiExtractorPackagePath: heftConfiguration.compilerPackage.apiExtractorPackagePath,
        typescriptPackagePath: apiExtractorTaskConfiguration?.useProjectTypescriptVersion
          ? heftConfiguration.compilerPackage.typeScriptPackagePath
          : undefined,
        buildFolder: buildFolder,
        production: production
      },
      heftSession
    );
    if (debugMode) {
      await apiExtractorRunner.invokeAsync();
    } else {
      await apiExtractorRunner.invokeAsSubprocessAsync();
    }
  }

  private async _doesAPiExtractorConfigExistAsync(heftConfiguration: HeftConfiguration): Promise<boolean> {
    if (await FileSystem.existsAsync(path.resolve(heftConfiguration.buildFolder, CONFIG_FILE_LOCATION))) {
      return true;
    }

    const rigConfig: RigConfig = await CoreConfigFiles.getRigConfigAsync(heftConfiguration);
    const rigConfigFolder: string = await rigConfig.getResolvedProfileFolderAsync();
    return await FileSystem.existsAsync(path.resolve(rigConfigFolder, CONFIG_FILE_LOCATION));
  }
}
