// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.

import * as path from 'path';
import type * as TApiExtractor from '@microsoft/api-extractor';
import type {
  IHeftTaskPlugin,
  IHeftTaskRunHookOptions,
  IHeftTaskSession,
  HeftConfiguration,
  IHeftTaskCleanHookOptions
} from '@rushstack/heft';
import { ConfigurationFile } from '@rushstack/heft-config-file';

import { ApiExtractorRunner } from './ApiExtractorRunner';

const PLUGIN_NAME: string = 'ApiExtractorPlugin';
const PLUGIN_SCHEMA_PATH: string = path.resolve(__dirname, 'schemas', 'api-extractor-task.schema.json');
const CONFIG_FILE_LOCATION: string = './config/api-extractor.json';

export interface IApiExtractorPluginConfiguration {
  /**
   * If set to true, use the project's TypeScript compiler version for API Extractor's
   * analysis. API Extractor's included TypeScript compiler can generally correctly
   * analyze typings generated by older compilers, and referencing the project's compiler
   * can cause issues. If issues are encountered with API Extractor's included compiler,
   * set this option to true.
   *
   * This corresponds to API Extractor's `--typescript-compiler-folder` CLI option and
   * `IExtractorInvokeOptions.typescriptCompilerFolder` API option. This option defaults to false.
   */
  useProjectTypescriptVersion?: boolean;
}

export default class ApiExtractorPlugin implements IHeftTaskPlugin {
  private _apiExtractorPromise: Promise<typeof TApiExtractor | undefined> | undefined;
  private _apiExtractorConfigurationFilePathPromise: Promise<string | undefined> | undefined;
  private _apiExtractorTaskConfigurationPromise:
    | Promise<IApiExtractorPluginConfiguration | undefined>
    | undefined;

  public apply(taskSession: IHeftTaskSession, heftConfiguration: HeftConfiguration): void {
    taskSession.hooks.clean.tapPromise(PLUGIN_NAME, async (cleanOptions: IHeftTaskCleanHookOptions) => {
      // Load up the configuration, but ignore if target files are missing, since we will be deleting
      // them anyway.
      const apiExtractorConfiguration: TApiExtractor.ExtractorConfig | undefined =
        await this._getApiExtractorConfigurationAsync(
          taskSession,
          heftConfiguration,
          /* ignoreMissingEntryPoint: */ true
        );
      if (apiExtractorConfiguration) {
        await this._updateCleanOptionsAsync(cleanOptions, apiExtractorConfiguration);
      }
    });

    taskSession.hooks.run.tapPromise(PLUGIN_NAME, async (runOptions: IHeftTaskRunHookOptions) => {
      const apiExtractor: typeof TApiExtractor | undefined = await this._getApiExtractorAsync(
        taskSession,
        heftConfiguration
      );
      const apiExtractorConfiguration: TApiExtractor.ExtractorConfig | undefined =
        await this._getApiExtractorConfigurationAsync(taskSession, heftConfiguration);
      if (apiExtractor && apiExtractorConfiguration) {
        await this._runApiExtractorAsync(
          taskSession,
          heftConfiguration,
          runOptions,
          apiExtractor,
          apiExtractorConfiguration
        );
      }
    });
  }

  private async _getApiExtractorConfigurationFilePathAsync(
    heftConfiguration: HeftConfiguration
  ): Promise<string | undefined> {
    if (!this._apiExtractorConfigurationFilePathPromise) {
      this._apiExtractorConfigurationFilePathPromise =
        heftConfiguration.rigConfig.tryResolveConfigFilePathAsync(CONFIG_FILE_LOCATION);
    }
    return await this._apiExtractorConfigurationFilePathPromise;
  }

  private async _getApiExtractorConfigurationAsync(
    taskSession: IHeftTaskSession,
    heftConfiguration: HeftConfiguration,
    ignoreMissingEntryPoint?: boolean
  ): Promise<TApiExtractor.ExtractorConfig | undefined> {
    const configObjectFullPath: string | undefined = await this._getApiExtractorConfigurationFilePathAsync(
      heftConfiguration
    );
    if (!configObjectFullPath) {
      return undefined;
    }

    const apiExtractor: typeof TApiExtractor = (await this._getApiExtractorAsync(
      taskSession,
      heftConfiguration
    ))!;
    const configObject: TApiExtractor.IConfigFile =
      apiExtractor.ExtractorConfig.loadFile(configObjectFullPath);

    return apiExtractor.ExtractorConfig.prepare({
      configObject,
      configObjectFullPath,
      ignoreMissingEntryPoint,
      packageJsonFullPath: path.join(heftConfiguration.buildFolder, 'package.json'),
      projectFolderLookupToken: heftConfiguration.buildFolder
    });
  }

  private async _getApiExtractorAsync(
    taskSession: IHeftTaskSession,
    heftConfiguration: HeftConfiguration
  ): Promise<typeof TApiExtractor | undefined> {
    if (!this._apiExtractorPromise) {
      this._apiExtractorPromise = this._getApiExtractorInnerAsync(taskSession, heftConfiguration);
    }
    return await this._apiExtractorPromise;
  }

  private async _getApiExtractorInnerAsync(
    taskSession: IHeftTaskSession,
    heftConfiguration: HeftConfiguration
  ): Promise<typeof TApiExtractor | undefined> {
    // API Extractor provides an ExtractorConfig.tryLoadForFolder() API that will probe for api-extractor.json
    // including support for rig.json.  However, Heft does not load the @microsoft/api-extractor package at all
    // unless it sees a config/api-extractor.json file.  Thus we need to do our own lookup here.
    const apiExtractorConfigurationFilePath: string | undefined =
      await this._getApiExtractorConfigurationFilePathAsync(heftConfiguration);
    if (!apiExtractorConfigurationFilePath) {
      return undefined;
    }

    const apiExtractorPackagePath: string = await heftConfiguration.rigToolResolver.resolvePackageAsync(
      '@microsoft/api-extractor',
      taskSession.logger.terminal
    );
    return await import(apiExtractorPackagePath);
  }

  private async _updateCleanOptionsAsync(
    cleanOptions: IHeftTaskCleanHookOptions,
    apiExtractorConfiguration: TApiExtractor.ExtractorConfig
  ): Promise<void> {
    const extractorGeneratedFilePaths: string[] = [];
    if (apiExtractorConfiguration.apiReportEnabled) {
      // Keep apiExtractorConfiguration.reportFilePath as-is, since API-Extractor uses the existing
      // content to write a warning if the output has changed.
      extractorGeneratedFilePaths.push(apiExtractorConfiguration.reportTempFilePath);
    }
    if (apiExtractorConfiguration.docModelEnabled) {
      extractorGeneratedFilePaths.push(apiExtractorConfiguration.apiJsonFilePath);
    }
    if (apiExtractorConfiguration.rollupEnabled) {
      extractorGeneratedFilePaths.push(
        apiExtractorConfiguration.alphaTrimmedFilePath,
        apiExtractorConfiguration.betaTrimmedFilePath,
        apiExtractorConfiguration.publicTrimmedFilePath,
        apiExtractorConfiguration.untrimmedFilePath
      );
    }
    if (apiExtractorConfiguration.tsdocMetadataEnabled) {
      extractorGeneratedFilePaths.push(apiExtractorConfiguration.tsdocMetadataFilePath);
    }

    for (const generatedFilePath of extractorGeneratedFilePaths) {
      if (generatedFilePath) {
        cleanOptions.addDeleteOperations({
          sourceFolder: path.dirname(generatedFilePath),
          includeGlobs: [path.basename(generatedFilePath)]
        });
      }
    }
  }

  private async _getApiExtractorTaskConfigurationAsync(
    taskSession: IHeftTaskSession,
    heftConfiguration: HeftConfiguration
  ): Promise<IApiExtractorPluginConfiguration | undefined> {
    if (!this._apiExtractorTaskConfigurationPromise) {
      this._apiExtractorTaskConfigurationPromise = this._getApiExtractorTaskConfigurationInnerAsync(
        taskSession,
        heftConfiguration
      );
    }

    return await this._apiExtractorTaskConfigurationPromise;
  }

  private async _getApiExtractorTaskConfigurationInnerAsync(
    taskSession: IHeftTaskSession,
    heftConfiguration: HeftConfiguration
  ): Promise<IApiExtractorPluginConfiguration | undefined> {
    const apiExtractorTaskConfigurationFileLoader: ConfigurationFile<IApiExtractorPluginConfiguration> =
      new ConfigurationFile<IApiExtractorPluginConfiguration>({
        projectRelativeFilePath: 'config/api-extractor-task.json',
        jsonSchemaPath: PLUGIN_SCHEMA_PATH
      });

    return await apiExtractorTaskConfigurationFileLoader.tryLoadConfigurationFileForProjectAsync(
      taskSession.logger.terminal,
      heftConfiguration.buildFolder,
      heftConfiguration.rigConfig
    );
  }

  private async _runApiExtractorAsync(
    taskSession: IHeftTaskSession,
    heftConfiguration: HeftConfiguration,
    runOptions: IHeftTaskRunHookOptions,
    apiExtractor: typeof TApiExtractor,
    apiExtractorConfiguration: TApiExtractor.ExtractorConfig
  ): Promise<void> {
    // TODO: Handle watch mode
    // if (watchMode) {
    //   taskSession.logger.terminal.writeWarningLine("API Extractor isn't currently supported in --watch mode.");
    //   return;
    // }

    const apiExtractorTaskConfiguration: IApiExtractorPluginConfiguration | undefined =
      await this._getApiExtractorTaskConfigurationAsync(taskSession, heftConfiguration);

    let typescriptPackagePath: string | undefined;
    if (apiExtractorTaskConfiguration?.useProjectTypescriptVersion) {
      typescriptPackagePath = await heftConfiguration.rigToolResolver.resolvePackageAsync(
        'typescript',
        taskSession.logger.terminal
      );
    }

    const apiExtractorRunner: ApiExtractorRunner = new ApiExtractorRunner({
      apiExtractor,
      apiExtractorConfiguration,
      typescriptPackagePath,
      buildFolder: heftConfiguration.buildFolder,
      production: runOptions.production,
      scopedLogger: taskSession.logger
    });

    // Run API Extractor
    await apiExtractorRunner.invokeAsync();
  }
}
