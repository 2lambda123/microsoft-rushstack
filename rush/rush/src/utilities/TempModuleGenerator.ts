
import * as colors from 'colors';
import * as os from 'os';
import * as path from 'path';
import * as fsx from 'fs-extra';
import * as semver from 'semver';

import {
  JsonFile,
  RushConfiguration,
  RushConfigurationProject,
  IPackageJson,
  Utilities
} from '@microsoft/rush-lib';

import ShrinkwrapFile from '../utilities/ShrinkwrapFile';

export class TempModuleGenerator {
  private _rushConfiguration: RushConfiguration;

  constructor(rushConfiguration: RushConfiguration) {
    this._rushConfiguration = rushConfiguration;
  }

  /**
   * Regenerates the common/package.json and all temp_modules projects.
   */
  public regenerate(): void {
    this.regenerateAndValidateShrinkwrap(undefined);
  }

  /**
   * Regenerates the common/package.json and all temp_modules projects.
   * If shrinkwrapFile is provided, this function also validates whether it contains
   * everything we need to install and returns true if so; in all other cases,
   * the return value is false.
   */
  public regenerateAndValidateShrinkwrap(shrinkwrapFile: ShrinkwrapFile|undefined): boolean {
    console.log('Creating temp projects...');
    if (fsx.existsSync(this._rushConfiguration.tempModulesFolder)) {
      Utilities.dangerouslyDeletePath(this._rushConfiguration.tempModulesFolder);
    }

    Utilities.createFolderWithRetry(this._rushConfiguration.tempModulesFolder);

    let shrinkwrapIsValid: boolean = true;

    if (shrinkwrapFile) {
      // Check any pinned dependencies first
      this._rushConfiguration.pinnedVersions.forEach((version: string, dependency: string) => {
        if (!shrinkwrapFile.hasCompatibleDependency(dependency, version)) {
          console.log(colors.yellow(
            `${os.EOL}The NPM shrinkwrap file does satisfy pinned version ${dependency}`
            + ` ("${version}").`));
          shrinkwrapIsValid = false;
        }
      });
    } else {
      shrinkwrapIsValid = false;
    }

    const commonPackageJson: PackageJson = {
      dependencies: {},
      description: 'Temporary file generated by the Rush tool',
      name: 'rush-common',
      private: true,
      version: '0.0.0'
    };

    // To make the common/package.json file more readable, sort alphabetically
    // according to rushProject.tempProjectName instead of packageName.
    const sortedRushProjects: RushConfigurationProject[] = this._rushConfiguration.projects.slice(0);
    sortedRushProjects.sort(
      (a: RushConfigurationProject, b: RushConfigurationProject) => a.tempProjectName.localeCompare(b.tempProjectName)
    );
    for (const rushProject of sortedRushProjects) {
      const packageJson: PackageJson = rushProject.packageJson;

      const tempProjectName: string = rushProject.tempProjectName;

      const tempProjectFolder: string = path.join(this._rushConfiguration.tempModulesFolder, tempProjectName);
      fsx.mkdirSync(tempProjectFolder);

      commonPackageJson.dependencies[tempProjectName] = 'file:./temp_modules/' + tempProjectName;

      const tempPackageJsonFilename: string = path.join(tempProjectFolder, 'package.json');

      const tempPackageJson: IPackageJson = {
        name: tempProjectName,
        version: '0.0.0',
        private: true,
        dependencies: {}
      };

      // If there are any optional dependencies, copy them over directly
      if (packageJson.optionalDependencies) {
        tempPackageJson.optionalDependencies = packageJson.optionalDependencies;
      }

      // Collect pairs of (packageName, packageVersion) to be added as temp package dependencies
      const pairs: { packageName: string, packageVersion: string }[] = [];

      // If there are devDependencies, we need to merge them with the regular
      // dependencies.  If the same library appears in both places, then the
      // regular dependency takes precedence over the devDependency.
      // It also takes precedence over a duplicate in optionalDependencies,
      // but NPM will take care of that for us.  (Frankly any kind of duplicate
      // should be an error, but NPM is pretty lax about this.)
      if (packageJson.devDependencies) {
        for (const packageName of Object.keys(packageJson.devDependencies)) {
          pairs.push({ packageName: packageName, packageVersion: packageJson.devDependencies[packageName] });
        }
      }

      if (packageJson.dependencies) {
        for (const packageName of Object.keys(packageJson.dependencies)) {
          pairs.push({ packageName: packageName, packageVersion: packageJson.dependencies[packageName] });
        }
      }

      for (const pair of pairs) {
        // Is there a locally built Rush project that could satisfy this dependency?
        // If so, then we will symlink to the project folder rather than to common/node_modules.
        // In this case, we don't want "npm install" to process this package, but we do need
        // to record this decision for "rush link" later, so we add it to a special 'rushDependencies' field.
        const localProject: RushConfigurationProject = this._rushConfiguration.getProjectByName(pair.packageName);
        if (localProject) {

          // Don't locally link if it's listed in the cyclicDependencyProjects
          if (!rushProject.cyclicDependencyProjects.has(pair.packageName)) {

            // Also, don't locally link if the SemVer doesn't match
            const localProjectVersion: string = localProject.packageJson.version;
            if (semver.satisfies(localProjectVersion, pair.packageVersion)) {

              // We will locally link this package
              if (!tempPackageJson.rushDependencies) {
                tempPackageJson.rushDependencies = {};
              }
              tempPackageJson.rushDependencies[pair.packageName] = pair.packageVersion;
              continue;
            }
          }
        }

        // We will NOT locally link this package; add it as a regular dependency.
        tempPackageJson.dependencies[pair.packageName] = pair.packageVersion;

        if (shrinkwrapFile) {
          if (!shrinkwrapFile.hasCompatibleDependency(pair.packageName, pair.packageVersion, tempProjectName)) {
            console.log(colors.yellow(
              `${os.EOL}The NPM shrinkwrap file does not provide dependency ${pair.packageName}`
              + ` ("${pair.packageVersion}") required by "${rushProject.packageName}".`));
            shrinkwrapIsValid = false;
          }
        }
      }

      JsonFile.saveJsonFile(tempPackageJson, tempPackageJsonFilename);
    }

    console.log('Writing common/package.json');
    const commonPackageJsonFilename: string = path.join(this._rushConfiguration.commonFolder, 'package.json');
    JsonFile.saveJsonFile(commonPackageJson, commonPackageJsonFilename);

    return shrinkwrapIsValid;
  }
}
