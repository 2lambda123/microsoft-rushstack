import * as glob from 'glob';
import * as colors from 'colors';
import * as os from 'os';
import * as path from 'path';
import * as fsx from 'fs-extra';
import * as semver from 'semver';
import * as wordwrap from 'wordwrap';
import globEscape = require('glob-escape');

import {
  AsyncRecycle,
  JsonFile,
  RushConfiguration,
  RushConfigurationProject,
  IPackageJson,
  Utilities
} from '@microsoft/rush-lib';

import ShrinkwrapFile from '../utilities/ShrinkwrapFile';

const MAX_INSTALL_ATTEMPTS: number = 5;

const wrap: (textToWrap: string) => string = wordwrap.soft(Utilities.getConsoleWidth());

/**
 * This class implements common logic between "rush install" and "rush generate".
 */
export default class InstallManager {
  private _rushConfiguration: RushConfiguration;

  constructor(rushConfiguration: RushConfiguration) {
    this._rushConfiguration = rushConfiguration;
  }

  /**
   * If the "npm-local" symlink hasn't been set up yet, this creates it, installing the
   * specified NPM version in the user's home directory if needed.
   */
  public ensureLocalNpmTool(forceReinstall: boolean): void {
    // Example: "C:\Users\YourName\.rush"
    const rushHomeFolder: string = path.join(this._rushConfiguration.homeFolder, '.rush');

    if (!fsx.existsSync(rushHomeFolder)) {
      console.log('Creating ' + rushHomeFolder);
      fsx.mkdirSync(rushHomeFolder);
    }

    // Example: "C:\Users\YourName\.rush\npm-1.2.3"
    const npmToolFolder: string = path.join(rushHomeFolder, 'npm-' + this._rushConfiguration.npmToolVersion);
    // Example: "C:\Users\YourName\.rush\npm-1.2.3\last-install.flag"
    const npmToolFlagFile: string = path.join(npmToolFolder, 'last-install.flag');

    // NOTE: We don't care about the timestamp for last-install.flag, because nobody will change
    // the package.json for this case
    if (forceReinstall || !fsx.existsSync(npmToolFlagFile)) {
      console.log(colors.bold('Installing NPM version ' + this._rushConfiguration.npmToolVersion) + os.EOL);

      if (fsx.existsSync(npmToolFolder)) {
        console.log('Deleting old files from ' + npmToolFolder);
        Utilities.dangerouslyDeletePath(npmToolFolder);
      }
      Utilities.createFolderWithRetry(npmToolFolder);

      const npmPackageJson: PackageJson = {
        dependencies: { 'npm': this._rushConfiguration.npmToolVersion },
        description: 'Temporary file generated by the Rush tool',
        name: 'npm-local-install',
        private: true,
        version: '0.0.0'
      };
      JsonFile.saveJsonFile(npmPackageJson, path.join(npmToolFolder, 'package.json'));

      console.log(os.EOL + 'Running "npm install" in ' + npmToolFolder);

      // NOTE: Here we use whatever version of NPM we happen to find in the PATH
      Utilities.executeCommandWithRetry('npm', ['install'], MAX_INSTALL_ATTEMPTS, npmToolFolder);

      // Create the marker file to indicate a successful install
      fsx.writeFileSync(npmToolFlagFile, '');
      console.log('Successfully installed NPM ' + this._rushConfiguration.npmToolVersion);
    } else {
      console.log('Found NPM version ' + this._rushConfiguration.npmToolVersion + ' in ' + npmToolFolder);
    }

    // Example: "C:\MyRepo\common\npm-local"
    const localNpmToolFolder: string = path.join(this._rushConfiguration.commonFolder, 'npm-local');
    if (fsx.existsSync(localNpmToolFolder)) {
      fsx.unlinkSync(localNpmToolFolder);
    }
    console.log(os.EOL + 'Symlinking "' + localNpmToolFolder + '"');
    console.log('  --> "' + npmToolFolder + '"');
    fsx.symlinkSync(npmToolFolder, localNpmToolFolder, 'junction');
  }

  /**
   * Regenerates the common/package.json and all temp_modules projects.
   */
  public createTempModules(): void {
    this.createTempModulesAndCheckShrinkwrap(undefined);
  }

  /**
   * Regenerates the common/package.json and all temp_modules projects.
   * If shrinkwrapFile is provided, this function also validates whether it contains
   * everything we need to install and returns true if so; in all other cases,
   * the return value is false.
   */
  public createTempModulesAndCheckShrinkwrap(shrinkwrapFile: ShrinkwrapFile | undefined): boolean {
    console.log(os.EOL + colors.bold('Updating temp_modules in ' + this._rushConfiguration.commonFolder));

    if (fsx.existsSync(this._rushConfiguration.tempModulesFolder)) {
      Utilities.dangerouslyDeletePath(this._rushConfiguration.tempModulesFolder);
    }

    Utilities.createFolderWithRetry(this._rushConfiguration.tempModulesFolder);

    let shrinkwrapIsValid: boolean = true;

    if (shrinkwrapFile) {
      // Check any pinned dependencies first
      this._rushConfiguration.pinnedVersions.forEach((version: string, dependency: string) => {
        if (!shrinkwrapFile.hasCompatibleDependency(dependency, version)) {
          console.log(colors.yellow(wrap(
            `${os.EOL}The NPM shrinkwrap file does satisfy "${dependency}"`
            + ` (${version}) from pinnedVersions.json.`)));
          shrinkwrapIsValid = false;
        }
      });
    } else {
      shrinkwrapIsValid = false;
    }

    const commonPackageJson: PackageJson = {
      dependencies: {},
      description: 'Temporary file generated by the Rush tool',
      name: 'rush-common',
      private: true,
      version: '0.0.0'
    };

    // Add any pinned versions to the top of the commonPackageJson
    this._rushConfiguration.pinnedVersions.forEach((version: string, dependency: string) => {
      commonPackageJson.dependencies[dependency] = version;
    });

    // To make the common/package.json file more readable, sort alphabetically
    // according to rushProject.tempProjectName instead of packageName.
    const sortedRushProjects: RushConfigurationProject[] = this._rushConfiguration.projects.slice(0);
    sortedRushProjects.sort(
      (a: RushConfigurationProject, b: RushConfigurationProject) => a.tempProjectName.localeCompare(b.tempProjectName)
    );
    for (const rushProject of sortedRushProjects) {
      const packageJson: PackageJson = rushProject.packageJson;

      const tempProjectName: string = rushProject.tempProjectName;

      const tempProjectFolder: string = path.join(this._rushConfiguration.tempModulesFolder, tempProjectName);
      fsx.mkdirSync(tempProjectFolder);

      commonPackageJson.dependencies[tempProjectName] = 'file:./temp_modules/' + tempProjectName;

      const tempPackageJsonFilename: string = path.join(tempProjectFolder, 'package.json');

      const tempPackageJson: IPackageJson = {
        name: tempProjectName,
        version: '0.0.0',
        private: true,
        dependencies: {}
      };

      // If there are any optional dependencies, copy them over directly
      if (packageJson.optionalDependencies) {
        tempPackageJson.optionalDependencies = packageJson.optionalDependencies;
      }

      // Collect pairs of (packageName, packageVersion) to be added as temp package dependencies
      const pairs: { packageName: string, packageVersion: string }[] = [];

      // If there are devDependencies, we need to merge them with the regular
      // dependencies.  If the same library appears in both places, then the
      // regular dependency takes precedence over the devDependency.
      // It also takes precedence over a duplicate in optionalDependencies,
      // but NPM will take care of that for us.  (Frankly any kind of duplicate
      // should be an error, but NPM is pretty lax about this.)
      if (packageJson.devDependencies) {
        for (const packageName of Object.keys(packageJson.devDependencies)) {
          pairs.push({ packageName: packageName, packageVersion: packageJson.devDependencies[packageName] });
        }
      }

      if (packageJson.dependencies) {
        for (const packageName of Object.keys(packageJson.dependencies)) {
          pairs.push({ packageName: packageName, packageVersion: packageJson.dependencies[packageName] });
        }
      }

      for (const pair of pairs) {
        // Is there a locally built Rush project that could satisfy this dependency?
        // If so, then we will symlink to the project folder rather than to common/node_modules.
        // In this case, we don't want "npm install" to process this package, but we do need
        // to record this decision for "rush link" later, so we add it to a special 'rushDependencies' field.
        const localProject: RushConfigurationProject = this._rushConfiguration.getProjectByName(pair.packageName);
        if (localProject) {

          // Don't locally link if it's listed in the cyclicDependencyProjects
          if (!rushProject.cyclicDependencyProjects.has(pair.packageName)) {

            // Also, don't locally link if the SemVer doesn't match
            const localProjectVersion: string = localProject.packageJson.version;
            if (semver.satisfies(localProjectVersion, pair.packageVersion)) {

              // We will locally link this package
              if (!tempPackageJson.rushDependencies) {
                tempPackageJson.rushDependencies = {};
              }
              tempPackageJson.rushDependencies[pair.packageName] = pair.packageVersion;
              continue;
            }
          }
        }

        // We will NOT locally link this package; add it as a regular dependency.
        tempPackageJson.dependencies[pair.packageName] = pair.packageVersion;

        if (shrinkwrapFile) {
          if (!shrinkwrapFile.hasCompatibleDependency(pair.packageName, pair.packageVersion, tempProjectName)) {
            console.log(colors.yellow(
              wrap(`${os.EOL}The NPM shrinkwrap file is missing "${pair.packageName}"`
              + ` (${pair.packageVersion}) required by "${rushProject.packageName}".`)));
            shrinkwrapIsValid = false;
          }
        }
      }

      JsonFile.saveJsonFile(tempPackageJson, tempPackageJsonFilename);
    }

    const commonPackageJsonFilename: string = path.join(this._rushConfiguration.commonFolder, 'package.json');
    JsonFile.saveJsonFile(commonPackageJson, commonPackageJsonFilename);

    return shrinkwrapIsValid;
  }

  /**
   * Runs "npm install" in the common folder, in one of three ways:
   * 1. No action because it is already up to date
   * 2. Incremental action ("npm prune", "npm install", etc).
   * 3. Full clean and "npm install"
   */
  public installCommonModules(cleanInstall: boolean): void {
    // Example: "C:\MyRepo\common\npm-local\node_modules\.bin\npm"
    const npmToolFilename: string = this._rushConfiguration.npmToolFilename;
    if (!fsx.existsSync(npmToolFilename)) {
      // This normally should never occur -- it indicates that some code path forgot to call
      // InstallManager.ensureLocalNpmTool().
      throw new Error('Expected to find local NPM here: "' + npmToolFilename + '"');
    }

    console.log(os.EOL + colors.bold('Checking node_modules in ' + this._rushConfiguration.commonFolder) + os.EOL);

    // Example: "C:\MyRepo\common\last-install.flag"
    const commonNodeModulesMarkerFilename: string =
      path.join(this._rushConfiguration.commonFolder, 'last-install.flag');
    const commonNodeModulesFolder: string = path.join(this._rushConfiguration.commonFolder, 'node_modules');

    // This marker file indicates that the last "rush install" completed successfully
    const markerFileExistedAtStart: boolean = fsx.existsSync(commonNodeModulesMarkerFilename);

    // Based on timestamps, can we skip this install entirely?
    if (!cleanInstall && markerFileExistedAtStart) {
      const potentiallyChangedFiles: string[] = [];

      // Consider the timestamp on the node_modules folder; if someone tampered with it
      // or deleted it entirely, then we can't skip this install
      potentiallyChangedFiles.push(commonNodeModulesFolder);

      // Additionally, if they pulled an updated npm-shrinkwrap.json file from Git,
      // then we can't skip this install
      potentiallyChangedFiles.push(this._rushConfiguration.shrinkwrapFilename);

      // NOTE: If commonNodeModulesMarkerFilename (or any of the potentiallyChangedFiles) does not
      // exist, then isFileTimestampCurrent() returns false.
      if (Utilities.isFileTimestampCurrent(commonNodeModulesMarkerFilename, potentiallyChangedFiles)) {
        // Nothing to do, because everything is up to date according to time stamps
        return;
      }
    }

    // Before we invoke NPM, clean the cache if requested
    if (cleanInstall) {
      if (this._rushConfiguration.cacheFolder) {
        const cacheCleanArgs: string[] = ['cache', 'clean', this._rushConfiguration.cacheFolder];
        console.log(os.EOL + `Running "npm ${cacheCleanArgs.join(' ')}"`);
        Utilities.executeCommand(npmToolFilename, cacheCleanArgs, this._rushConfiguration.commonFolder);
      } else {
        // Ideally we should clean the global cache here.  However, the global NPM cache
        // is (inexplicably) not threadsafe, so if there are any concurrent "npm install"
        // processes running this would cause them to crash.
        console.log(os.EOL + 'Skipping "npm cache clean" because the cache is global.');
      }
    }

    if (markerFileExistedAtStart) {
      // Delete the successful install file to indicate the install transaction has started
      fsx.unlinkSync(commonNodeModulesMarkerFilename);
    }

    // Is there an existing "node_modules" folder to consider?
    if (fsx.existsSync(commonNodeModulesFolder)) {
      // Should we delete the entire "node_modules" folder?
      if (cleanInstall || !markerFileExistedAtStart) {
        // YES: Delete "node_modules"

        // Explain to the user why we are hosing their node_modules folder
        if (!cleanInstall) {
          console.log('Deleting the "node_modules" folder because the previous Rush install' +
            ' did not complete successfully.');
        } else {
          console.log('Deleting old files from ' + commonNodeModulesFolder);
        }

        AsyncRecycle.recycleDirectory(this._rushConfiguration, commonNodeModulesFolder);

        // Since it may be a while before NPM gets around to creating the "node_modules" folder,
        // create an empty folder so that the above warning will be shown if we get interrupted.
        Utilities.createFolderWithRetry(commonNodeModulesFolder);
      } else {
        // NO: Do an incremental install in the "node_modules" folder

        console.log(`Running "npm prune" in ${this._rushConfiguration.commonFolder}`);
        Utilities.executeCommandWithRetry(npmToolFilename, ['prune'], MAX_INSTALL_ATTEMPTS,
          this._rushConfiguration.commonFolder);

        // Delete the (installed image of) the temp projects, since "npm install" does not
        // detect changes for "file:./" references.
        // We recognize the temp projects by their names, which always start with "rush-".

        // Example: "C:\MyRepo\common\node_modules\rush-"
        const pathToDeleteWithoutStar: string = path.join(commonNodeModulesFolder, 'rush-');
        console.log(`Deleting ${pathToDeleteWithoutStar}*`);
        // Glob can't handle Windows paths
        const normalizedpathToDeleteWithoutStar: string
          = Utilities.getAllReplaced(pathToDeleteWithoutStar, '\\', '/');
        for (const tempModulePath of glob.sync(globEscape(normalizedpathToDeleteWithoutStar) + '*')) {
          Utilities.dangerouslyDeletePath(tempModulePath);
        }
      }
    }

    // Run "npm install" in the common folder
    const npmInstallArgs: string[] = ['install'];
    if (this._rushConfiguration.cacheFolder) {
      npmInstallArgs.push('--cache', this._rushConfiguration.cacheFolder);
    }

    if (this._rushConfiguration.tmpFolder) {
      npmInstallArgs.push('--tmp', this._rushConfiguration.tmpFolder);
    }

    console.log(os.EOL + `Running "npm ${npmInstallArgs.join(' ')}" in ${this._rushConfiguration.commonFolder}`
      + os.EOL);
    Utilities.executeCommandWithRetry(npmToolFilename,
      npmInstallArgs,
      MAX_INSTALL_ATTEMPTS,
      this._rushConfiguration.commonFolder);

    // Finally, create the marker file to indicate a successful install
    fsx.createFileSync(commonNodeModulesMarkerFilename);
    console.log('');
  }
}
